# 일급 객체 first-class object

일급 객체란 일반 객체처럼 모든 연산이 가능한 것

- 함수의 매개변수로 전달
- 함수의 반환값
- 할당 명령문
- 동일 비교 대상

→ 일반 데이터처럼 사용이 가능하다!
<br />
<br />

# 일급 함수 first-class function

**함수가** 일급 객체란 일반 객체처럼 모든 연산이 가능한 것

- 함수의 매개변수로 전달
- 함수의 반환값
  → 함수 안에서 함수 자체를 반환
- 할당 명령문
  → 함수를 어떤 변수에 할당
- 동일 비교 대상
  → 함수 자체를 비교할 수 있는

→ 즉 이 모든 것이 가능한 것을 일급함수라고 한다

<br />
<br />

# 고차함수 Higher-order function

- 인자로 함수를 받음(콜백함수)
- 함수를 반환하는 함수

→ 즉 함수에서 다른 함수를 인자로 받거나 반환하는 함수를 고차함수라고 한다

<br />

만약 콜백함수를 인자로 받았다면 함수 안에서 필요한 순간에 인자로 전달받은 콜백함수를 호출할 수 있는 권한이 있다.

<br />

즉, 높은 권한, 높은 순서에 있다고 해서 higher-order function 고차함수라고 이름이 지어진 것이다.

<br />
<br />

**그렇다면 배열을 배우다가 왜 갑자기 일급 함수 고차함수에 대하여 배울까?**
<br />
<br />

### 바로 배열에서도 유용하게 사용할 수 있는 고차함수들이 많기 때문이다

이렇게 함수 단위로 엮어나가는 것을 함수형 프로그래밍이라고 한다.

절차 지향적으로 for, if문을 이용하여 절차형으로 프로그래밍을 해나가는 것이 아니라 어떠한 특정한 일을 하는 함수들 끼리 서로 엮어놓는, 연결해놓는 것을 **함수형 프로그래밍**이라고 한다.

이것은 코딩을 해나가는 방식을 말하는데 이렇게 함수형 프로그래밍을 하기 위해서는 함수 자체를 **순수 함수**로 만들어야 한다.

<br />
<br />

**그렇다면 순수 함수란 무엇인가?**
<br />

### 바로 함수 안에서 불변성을 유지하는 것이다.

함수 안에서 전달받은 매개변수나, 또는 함수 밖에 있는 특정한 상태를 함수 내부에서 수정하지 않고 전달받은 인자를 통해서 함수에서 특정한 연산이나 일을 수행한 다음 새로운 값을 리턴하는 것이다.

이것을 함수 내부에서 side effect이 없다고도 한다.

side effect이란 예상하지 않은 부작용, 결과와는 상관없는 side effect을 만든다는 뜻이다.

### 즉, 함수 내부에서는 함수 외부의 상태를 변경하지 않는다!

이렇게 순수 함수로 만들면 에러도 줄이고 가독성도 높일 수 있다.

**그래서 함수형 프로그래밍을 사용하면 데이터 변경 X, 변수 사용 X, 조건문 사용 X, 반복문 사용 X, 조금 더 깔끔하게 코드를 짤 수 있다.**

### 이렇게 배열에서도 함수형 프로그래밍으로 사용할 수 있다!

<br />
<br />
<br />

## 고차 함수 사용해보기

```jsx
const fruits = ["🍌", "🍓", "🍇", "🍓"];
```

<br />

### 이 배열을 하나하나씩 출력하려면 어떻게 해야 할까?

```jsx
for (let i = 0; i < fruits.length; i++) {
  console.log(fruits[i]);
}
```

→ 원래대로라면 for 문을 이용하여 하나하나씩 배열을 돌아 출력하게 했다.

그런데 이렇게 배열을 사용할 때마다 for문을 사용하면 지저분하고 작성하기도 귀찮은 불편함이 있다

<br />
<br />

**이것을 간편하게 할 수 있는 고차함수가 있다!**

### 바로 배열에 있는 forEach을 사용하면 된다

forEach를 살펴보면 배열에 있는 요소마다 주어진 액션을 취하게 한다고 설명이 되어 있다.

forEach에는 인자로 콜백함수를 전달한다.

```jsx
forEach(callbackfn: (value, index, array) => void)
```

→ 이 콜백함수는 배열의 요소를 하나하나 넣어서 함수를 호출한다.

<br />

배열의 요소와, 배열의 인덱스, 배열의 전체, 총 세 개의 인자를 전달해서 우리가 전달하는 콜백함수를 호출해준다.

```jsx
fruits.forEach(function (value) {
  console.log(value);
});
fruits.forEach((value) => console.log(value));
```

→ 화살표 함수를 이용하여 콜백함수를 호출하는 방법도 있다.

<br />

### 조건에 맞는(콜백함수) 아이템을 찾을 때

```jsx
const item1 = { name: "🥛", price: 2 };
const item2 = { name: "🍪", price: 3 };
const item3 = { name: "🍙", price: 1 };
const products = [item1, item2, item3, item2];
```

→ 이 배열에서 쿠키를 찾고 싶다면 어떻게 해야 할까?
<br />
<br />

### 예전에는 위와 동일하게 for문을 이용하여 뱅글뱅글 돌면서 하나하나 찾았지만 이번에는 고차함수 find를 사용하여 찾아보자

```
let result = products.find((item) => item.name === "🍪");
console.log(result);
```

- **find**: 제일 먼저 조건에 맞는 아이템을 반환
  <br />
  <br />

**여기서 조건에 맞는 아이템의 인덱스를 반환하고 싶다면 어떻게 해야 할까?**

**→ findIndex :** 제일 먼저 조건에 맞는 인덱스를 반환
<br />
<br />

### 배열의 아이템들이 부분적으로 조건(콜백함수)에 맞는지 확인

```jsx
result = products.some((item) => item.name === "🍪");
console.log(result);
```

- **some**: 배열에 있는 어떤 것이라도 하나라도 맞는지 확인하여 true / false로 값을 출력한다

<br />
<br />

### 배열의 아이템들이 전부 조건(콜백함수)에 맞는지 확인

```jsx
result = products.every((item) => item.name === "🍪");
console.log(result);
```

- **every**: 배열에 있는 모든 것이 조건에 맞는지 확인하여 true / false로 값을 출력한다

<br />
<br />

### 조건에 맞는 모든 아이템들을 새로운 배열로 반환

```jsx
result = products.filter((item) => item.name === "🍪");
console.log(result);
```

- **fliter** : 조건에 맞는 모든 아이템들을 새로운 배열로 반환

→ 즉, 내가 원하는 조건으로만 새로운 배열을 생성할 수 있다
<br />
<br />

### Map

→ 배열의 아이템들을 각각 다른 아이템으로 매핑할 수 있는, 변환해서 새로운 배열 생성

![Untitled](https://blog.kakaocdn.net/dn/6kMBV/btqR3QZtsGf/CpcUNfSAurzKCo88WkPXgk/img.png)

→ 배열에 1, 2, 3이라는 요소가 있다면 map이라는 고차함수를 이용하여 주어진 요소에 각각 10을 곱하면 1은 10, 2는 20, 3은 30으로 매핑된 새로운 배열을 만들어낼 수 있다.
<br />
<br />

이렇게 map을 이용하면 mapping하다는 느낌이다.

```jsx
const nums = [1, 2, 3, 4, 5];
result = nums.map((item) => item * 2);
console.log(result); //2, 4, 6, 8, 10
```

→ num이라는 배열에 2를 곱하여 새롭게 반환하면 위와 같이 2, 4, 6, 8, 10이 나온다
<br />
<br />

**그렇다면 짝수일 때만 2배를 하고 싶다면 어떻게 해야 할까?**

```jsx
result = nums.map((item) => {
  if (item % 2 === 0) {
    return item * 2;
  } else {
    return item;
  }
});
console.log(result); // 1, 4, 3, 8, 5
```

→ 이렇게 map을 이용하면 원하는 특정한 요소를 다른 요소로 mapping, 변환할 수 있다
<br />
<br />
**map은 하나당 하나를 연결, mapping 해주는데 여러 중첩된 것을 mapping할 때는 어떻게 해야 할까?**
<br />
<br />
<br />

### Flatmap

중첩된 배열을 쫘악 펴서 새로운 배열 생성

![Untitled](https://reactivex.io/documentation/operators/images/flatMap.png)

→ 상단의 동그라미들이 배열이라고 생각해보자

배열을 하나하나씩 풀어서 각각 낱개로 풀어서 리턴해주는 것을 확인할 수 있다.

```jsx
result = nums.map((item) => [1, 2]);
console.log(result); // [[1, 2], [1, 2],[1, 2],[1, 2],[1, 2]]
```

→ 위의 nums 배열을 [1, 2]인 각각의 새로운 배열을 만들고 싶다면 map을 이용하여 만들어보자

이렇게 각각의 숫자당 [1, 2]가 들어가 배열 안에 배열이 들어간 배열을 확인할 수 있다.

### 그렇다면 이것을 map이 아닌 flatMap을 이용해보자

```jsx
result = nums.flatMap((item) => [1, 2]);
console.log(result); // [ 1, 2, 1, 2, 1, 2, 1, 2, 1, 2 ]
```

→ 이렇게 각각의 배열들이 쫙 펴져서 하나의 배열로 출력이 되는 것을 확인할 수 있다

**그렇다면 이것을 어떻게 유용하게 쓸 수 있을까?**

아래와 같이 "dream", "coding"이라는 문자열의 배열이 있는데 이것을 알파벳 하나하나 구성하고 싶을 때 한번 map을 이용하여 보자

```jsx
result = ["dream", "coding"].map((text) => text.split(""));
console.log(result);
//[ [ 'd', 'r', 'e', 'a', 'm' ], [ 'c', 'o', 'd', 'i', 'n', 'g' ] ]
```

→ 이렇게 문자열이 또 각각의 배열이 되어 배열 안에 배열이 중첩된 구조로 나오는 것을 확인할 수 있다.

<br />
<br />

### 그렇다면 flatMap을 활용해보자

```jsx
result = ["dream", "coding"].flatMap((text) => text.split(""));
console.log(result);
// 'd', 'r', 'e', 'a', 'm', 'c', 'o', 'd', 'i', 'n', 'g'
```

→ 이렇게 원하는대로 알파벳 하나하나씩 반환이 된 것을 확인할 수 있다.
<br />
<br />

### sort

배열의 아이템들을 정렬

→ 문자열 형태의 오름차순으로 요소를 정렬하고, 기존의 배열을 변경

```jsx
const texts = ["hi", "abc"];
texts.sort();
console.log(texts); //[ 'abc', 'hi' ]
```

→ 'abc'가 먼저 나오고 'hi'가 뒤에 나오는 것을 확인할 수 있다.

이와같이 그냥 sort를 사용하면 알파벳 오름차순으로 요소를 정렬한다
<br />
<br />

### sort를 사용할 때에는 숫자를 조심해야 한다!

숫자는 문자열로 변환이 되어서 그 상태로 정렬이 되기 때문에 조심해서 사용해야 한다

```jsx
const numbers = [0, 5, 4, 2, 1, 10];
numbers.sort();
console.log(numbers); //[ 0, 1, 10, 2, 4, 5 ]
```

→ 문자열 형태로 변환이 되어서 인식하다보니 0, 1 다음에 1 뒤에 0이 붙은 10, 그 다음 2, 4, 5로 출력한다
<br />
<br />

### 그렇다면 0. 1, 2, 4, 5, 10으로 출력을 하려면 어떻게 해야 할까?

어떻게 sorting할지 그 기준점을 함수로 전달해줘야 한다!

```jsx
numbers.sort((a, b) => a - b);
console.log(numbers); //0, 1, 2, 4, 5, 10
```

→ a, b라고 하면 두 요소가 전달이 된다. 처음에 a에는 0, b에는 5가 전달되고 리턴, 그 다음에는 5, 4 그 다음에는 4, 2 이렇게 순차적으로 두개씩 전달하여 비교할 수 있게 해준다.
<br />
<br />

**즉, a와 b를 전달받아 a - b를 했을 때 마이너스라면 a가 b보다 작다!**

이것을 기준으로 sorting을 해주면 된다!

**전달한 콜백함수의 결과가 < 0면, a가 앞으로 정렬**

→ 오름차순으로 정렬

**전달한 콜백함수의 결과가 > 0라면 b가 앞으로 정렬**

→ 내림차순으로 정렬
<br />
<br />
<br />

### reduce

배열의 요소들을 접어서 접어서 값을 하나로 만든다

![Untitled](https://blog.kakaocdn.net/dn/bIwuTj/btqRXIAWWFb/YB4N2wp45DwC1uRDnljvK0/img.png)

→ 1, 2, 3, 4, 5라는 값이 있다면 reduce를 통해서 주어진 요소들을 더하고 있다.
<br />
<br />

즉, 주어진 값들을 계속 더하면서 값을 하나로 만드는 것이다

1과 2를 더하면 3, 3에다가 3을 더하면 6, 6에 4를 더하면 10, 10에 5를 더하면 15 즉, 리턴하는 값은 15이다

```jsx
result = [1, 2, 3, 4, 5].reduce((sum, value) => (sum += value), 0);
console.log(result); //15
```

→ 1, 2, 3, 4, 5라는 배열을 계속 더해서 저장할 인자 sum과 sum이 계속 합해질 값을 저장할 value를 인자로 가지고 있다
<br />
<br />

여기에서 sum에 value를 더한 값을 리턴할 것이다.

이렇게 콜백함수를 만들었다면 처음에 시작할 값, 계속 더해나갈 값을 초기화해줄 인자를 두번째 인자로 할당해줄 수 있다.

즉, sum은 0, value 1 리턴한 값은 1, sum은 1 value 2 리턴한 값은 3, sum은 3, value 3 리턴한 값은 6 이런식으로 sum이라는 값에 계속 업데이트 해주면서 최종적으로 더해진 값이 result에 할당이 될 것이다
