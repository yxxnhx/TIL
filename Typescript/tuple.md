# Tuple 튜플

배열이긴 배열인데 서로 다른 타입을 함께 가질 수 있는 타입이다.

원래 배열은 선언할 때 문자열만 들어갈 것인지, 숫자만 들어갈 것인지 정하고 그 이후에는 선언한 것 외에는 들어갈 수 없다.

튜플을 사용하게 되면 서로 다른 타입의 데이터를 가질 수 있다.

**다음의 예시를 보자.**

```jsx
let student: [string, number];
student = ['name', 123];
```

이와같이 첫번째는 문자열 두번째는 숫자를 넣고 그에 맞게 할당하여 사용할 수 있다.

그렇다면 각각의 데이터에 접근할 때는 어떻게 해야할까?

```tsx
student[0]; //name
student[1]; //123
```

→ 배열에 접근하듯이 인덱스 번호로 접근을 할 수 있다. 그러나 매우 명시성이 떨어지고 불편하다.

그러므로 튜플을 사용하는 것을 권장하지 않는다.

데이터에 접근할 때 인덱스처럼 접근하는 것이 가독성이 떨어진다.

튜플 대신에 오브젝트 형식 혹은 클래스 형태로 사용하는 것이 훨씬 가독성이 좋다.

그렇다면 `student.name` 혹은 `student.age` 등으로 접근을 할 수 있기 때문이다.

그러므로 튜플을 사용할 수 있는 곳이라면 interface, type alias, class 등으로 대체하여 사용하는 곳이 좋다.

**그렇다면 인덱스 번호로 접근 말고 다른 방법은 없을까?**

정답은 있기는 있다.

구조분해할당처럼 오브젝트 디스트럭처링을 하면 된다.

```jsx
const [name, age] = student;
```

이처럼 첫번째 값은 name, 두번째 값은 age로 할당되게 할 수 있다.

이제 이렇게 접근하면 조금 더 명확하게 정보를 확인할 수는 있다.

그러나 그래도 여전히 데이터를 사용하는 곳에서 name과 age로 결정하고 사용해야 한다는 단점이 있다.

**그럼 이런 튜플을 사용한 예제가 있을까?**

생각보다 굉장히 많이 보고 접했던 예제가 있다.

```jsx
const [count, setCount] = useState(0);
```

바로 useState와 같은 hook이다.

튜플을 배열 디스트럭처링해서 받은 것과 리액트에서 useState를 호출하면 두 가지 count, setCount를 받아오는 것과 형식이 동일하다는 것을 확인할 수 있다.

useState에 대해서 잠깐 확인해보면 useState 함수가 반환하는 값은 배열인데 각각의 배열이 서로 다른 타입인 것을 확인할 수 있다.

이런 경우에는 튜플을 굉장히 유연하게 잘 활용한 경우이다.

사용자가 어떠한 변수를, 즉 숫자가 될 수도 문자가 될 수도 있는 다양한 초기값을 업데이트하고 세팅할 수 있게 만들어서 동적으로 반환할 수 있고, 사용하는 사람이 각각의 타입을 이름을 정해서 사용하여 쓸 수 있도록 만든 것이다.

그러나 이것을 너무 남용해서 interface, type alias, class 등으로 대체하여 사용할 수 있음에도 튜플을 사용해서 명시성, 가독성을 떨어뜨리지 않게 조심해야 한다.
