# 실행 컨텍스트 Execution Context

함수를 실행하고 호출하는 순서를 기억하는 것은 call stack을 통해서 기억한다.

그렇다면 어떻게 돌아올 때 반환된 값을 기억하는 것일까?

스코프에서도 외부 내부를 어떻게 기억해서 돌아오는 것일까?

**바로 실행 컨텍스트가 코드의 실행 순서와 스코프를 기억하기 때문이다!**

자바스크립트 런타임 환경에서 콜스택이 있다.

그 콜스택에서 함수의 실행 순서를 하나하나 기억하고 관리한다.

자바스크립트 엔진에서는 단 하나의 싱글 컨텍스트 스택이 있다.

그러므로 한 번에 하나의 일만 처리할 수 있다.

**그렇다면 이 예제를 보며 확인해보자**

```jsx
const a = 1;
{
  const a = 2;
  {
    const a = 3;
  }
}
```

동일한 이름의 a라는 변수를 전역에서, 블럭 안에서, 그리고 또 그 블럭 안에서 선언을 해도 이름 충돌을 피할 수 있다.

내부에서 a에 접근을 하면 내부에 a의 여부를 확인해보고 없다면 바로 근접한 곳에서 a가 있는지 찾아봐서 값을 반환한다. 만약 근접한 블럭에도 없다면 전역 변수로 있는지 여부를 확인한 후에 값을 반환한다.

```jsx
const a = 1; // 전역 스코프
{
  const a = 2; // 블럭 1 스코프
  {
    const a = 3; // 블럭 2 스코프
  }
}
```

그렇게 전역에 선언된 것을 전역 스코프, 블럭 안에 선언된 것을 블럭 스코프라고 한다.

블럭 안에 블럭이 중첩되어 있으므로 편의상 블럭 1 스코프, 블럭 2 스코프라고 칭해보자.

**그렇다면 어떻게 내 블럭 안에 이 변수의 데이터의 여부와 없다면 근접한 스코프에 변수의 데이터 여부를 확인할까?**

바로 각각의 블록은 렉시컬 환경 Lexical Environment라는 내부 오브젝트를 가지고 있다.

즉, 블록마다 어떤 변수를 가지고 있는지, 그리고 부모는 누가 있는지 모든 정보를 가지고 있는 오브젝트이다.

함수, 블럭 등 그 어떠한 블럭이라면 모든 정보를 가지고 있다.

자바스크립트 엔진은 자동으로 되는 것이 아니라 각각의 블럭에 대한 정보를 오브젝트 안에 담고 있다.

### 렉시컬 환경 Lexical Environment

렉시컬 환경은 두 가지 정보를 가지고 있다

- 환경 레코드 Environment Record : 현재 블럭의 정보
- 외부 환경 참조 Outrer Lexical Environment Reference : 부모의 정보

**그렇다면 위의 예시는 어떻게 될까?**

```jsx
const a = 1; // 전역 스코프
{
  const a = 2; // 블럭 1 스코프
  {
    const a = 3; // 블럭 2 스코프
  }
}
```

- 전역 스코프
  - 환경 레코드는 `a = 1`,
  - 외부 환경 참조는 `null`이다.
  → 전역 스코프에서는 글로벌로 선언이 되었기 때문에 참조할 부모가 없기 때문이다.
- 블럭 1 스코프
  - 환경 레코드 : `a = 2`
  - 외부 환경 참조 : `전역 스코프`
- 블럭 2 스코프
  - 환경 레코드 : `a = 3`
  - 외부 환경 참조: `블럭 1 스코프`

각각의 전역 스코프, 블럭 1 스코프, 블럭 2 스코프들이 스코프 체인으로 연결이 되어 각각의 부모를 가리키고 있다.

실행 컨텍스트 스택에서는 전역 스코프를 먼저 담고 그 다음 블럭 1 스코프, 그 다음으로는 블럭 2 스코프를 담는다

이제 블럭 2 스코프가 끝난다면 삭제하고 그 다음으로 블럭 1 스코프, 그 다음으로 전역 스코프를 종료 후에 실행 컨텍스트 스택을 비우게 된다.

**그렇다면 만약 블럭 2 스코프에 다음과 같이 a를 콘솔에 찍어본다면 어떻게 될까?**

```jsx
const a = 1; // 전역 스코프
{
  const a = 2; // 블럭 1 스코프
  {
    console.log(a); // 블럭 2 스코프
  }
}
```

→ 블럭 2 스코프에는 a가 선언되어있지 않기 때문에 스코프 체인을 타고 블록 2의 부모인 블록 1로 가서 a 변수를 찾게 되는 것이다.

그러므로 결국 콘솔에는 2가 찍히게 되는 것!

만약 블럭 1에도 a가 없다면 또 다시 스코프 체인을 타고 전역 스코프까지 가서 변수 a를 찾고 값을 받아오는 것이다.

### 이를 통해 메모리 절약 뿐만 아니라, 성능을 위해서라도 변수는 최대한 필요한 곳에서 정의를 해야 한다는 것을 알 수 있다!
