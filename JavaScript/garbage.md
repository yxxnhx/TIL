# 쓰레기 수집 Garbage Collection

C언어에서는 개발자가 직접 메모리 관리를 해야하지만 java, javascript, go 등에서는 엔진에서 자체적으로 제공되어 메모리 관리를 해주는 기능이 있다.

그것이 바로 가비지 컬랙터 Garbage Collector

줄여서 GC라고 부르기도 한다

**다음 예시를 보며 확인해보자**

```jsx
let apple = {
  name: 'apple',
};
```

위와 같이 apple이라는 오브젝트가 있다고 해보자.

apple이라는 변수는 name: ‘apple’이라는 메모리가 저장된 메모리 주소를 참조하고(가지고) 있다.

여기에서 다음과 같이 orange가 apple이라고 선언을 해보자

```jsx
let orange = apple;
```

그렇다면 orange도 apple과 동일한 메모리 주소를 가지고 있을 것이다.

그런데 다음과 같이 orange와 apple은 null이라고 재선언을 해보자

```jsx
orange = null;
apple = null;
```

**그렇다면 어떤 일이 일어날까?**

name: ‘apple’은 더이상 그 어떤 곳에서도 참조를 하고 있지 않기 때문에 더이상 필요가 없다고 판단하고 가비지 컬랙터가 해당 메모리를 치운다.

즉, 가비지 컬렉터란 자바스크립트 엔진에서 자체적으로 제공하는 것

백그라운드 프로세스에서 구동되는 것이다

결국 백그라운드에서 구동이 된다는 것은 cpu를 사용한다는 것이므로

너무 자주 빈번하게 불필요한 메모리를 재할당하고 사용하지 말고 필요한 곳에서만 선언하고 사용해야 한다.

**다음 예시를 보며 정리를 해보자**

```jsx
const global = 1;
{
  const local = 1;
}
```

- global로 선언된 글로벌 변수는 앱이 종료될 때까지 계속 메모리에 유지된다
- local로 선언된 로컬 변수는 블럭 내부에만 존재하고, 블럭이 끝나면 자동으로 소멸이 된다.

엄밀히 말하면 가비지 컬랙터에 의해 정리가 되는 것이다

가비지 컬랙터에 주기적으로 메모리를 검사해서 더이상 참조하는 곳이 없다면 메모리에서 삭제하고 정리하는 것이다.

**그렇다면 함수의 경우에서는 어떻게 해야 할까?**

```
function print() {
  if (true) {
    let temp = 0;
  }
}
```

함수 내부에서도 블럭 안에서 필요한 겨웅에는 필요한 곳에서! 블럭 안에서 선언하고 사용하는 것이 메모리 낭비를 방지할 수 있다.

예를 들어 위와 같이 if 문 안에서만 필요한 temp일 경우에는 if문 안에서 변수를 선언하고 if문이 종료되었을 때는 temp가 소멸될 수 있도록 해야 하는 것이다.
