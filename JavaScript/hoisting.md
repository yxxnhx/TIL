# 호이스팅 Hoisting

<aside>
💡 hoist : 끌어올리다

</aside>

프로그래밍 언어에서 호이스팅이란 변수나 함수나 클래스의 선언문을 파일 제일 아래에 선언해도 제일 위로 끌어올려주는 것을 말한다.

자바스크립트 엔진이 코드를 실행하기 전 코드를 쭉 스캔 후에 변수, 함수, 클래스 등의 선언을 끌어올려주기 때문이다.

코드를 실행하기 전에 한번씩 쭉 보면서 각각 렉시컬 환경을 만드는데 각각 어떤 데이터가 있고 어떤 부모를 가지고 있는지 오브젝트로 가져서 미리 선언을 해준다.

결국 변수의 선언과 초기화를 분리한 뒤에 선언만 최상단으로 옮겨준다!

**다음 예시를 보자**

```jsx
let a = 0;
```

만약 코드 하단에 위와 같이 a를 선언하였다면 자바스크립트 엔진에서는 a에 어떤 값을 할당해주었든 a가 선언되었다는 사실만 코드 최상단에 끌어올려주는 것이다.

그러므로 여기에서 가장 밀접하게 관련되어 있는 것이 있다.

### 바로 변수이다.

변수는 값을 저장하는 공간, 자료를 저장할 수 있는 이름이 주어진 기억 장소이다.

- let: 값 재할당 가능
- const : 재할당 불가능

가능한 const를 사용하고 값이 정말 재할당이 필수적일 경우에만 let을 사용하는 것이 좋다.

**다음 예시를 한번 보자**

```jsx
function print() {
  console.log('hello'); //hello
}

print();
```

위와 같이 print라는 함수가 있다고 가정해보자

평소처럼 함수 밑에서 print 함수를 호출하면 콘솔에 hello가 찍히는 것을 확인할 수 있다.

**그런데 한번 print 함수를 먼저 호출하면 어떻게 될까?**

```jsx
print();

function print() {
  console.log('hello'); //hello
}
```

→ 정상적으로 hello가 호출되는 것을 확인할 수 있다.

위에서 보았듯이 자바스크립트 엔진은 코드를 실행하기 전에 코드를 스캔 후에 함수의 선언을 호이스팅을 하기 때문에 함수를 먼저 호출 후에 선언을 해도 정상적으로 호출이 된다.

- 함수의 호이스팅은 함수의 선언문 전에 호출이 가능하게 해준다
- 함수의 선언문은 선언 이전에도 호출이 가능하다!

### **그렇다면 이 경우에는 어떻게 될까?**

```jsx
let hi = 'hi';

console.log(hi); //hi
```

이렇게 hi라는 변수를 콘솔에 찍어보면 정상적으로 값이 나오는 것을 확인할 수 있다.

**그렇다면 변수를 선언하기 전에 먼저 호출하면 어떻게 될까?**

```jsx
console.log(hi);

let hi = 'hi';
```

→ hi is undefind라는 에러 대신에 hi를 초기화해주기 전까지는 접근할 수 없다는 에러를 볼 수 있다.

즉, hi라는 변수를 알긴 아는데 초기화가 되지 않았다는 것이다.

**변수(let, const)와 클래스는 선언만 호이스팅이 되고, 초기화는 안된다.**

**초기화 전, 변수에 접근하면 컴파일(빌드) 에러가 발생한다**

즉, 그 변수, 클래스가 있다는 것만 호이스팅이 되니 있다는 것만 알고 초기화는 되지 않아 선언한 코드에 가야만 초기화가 되어 호출하거나 사용이 가능하다는 뜻이다.

**그렇다면 표현식으로 함수를 선언하면 어떻게 될까?**

```jsx
console.log(functionHi);

let functionHi = function () {
  console.log(hi);
};
```

→ 동일하게 초기화해주기 전까지는 접근하지 못한다는 것을 알 수 있다.

**그렇다면 클래스의 경우는 어떨까?**

```jsx
class Cat {}
const cat = new Cat();
```

이렇게 아래에서는 cat을 선언할 수 있지만

```jsx
const cat = new Cat();
class Cat {}
```

먼저 cat을 선언한 후에 클래스를 생성할 경우에는 동일하게 초기화해주기 전까지는 접근이 불가능하다는 에러를 볼 수 있다.

### 그렇다면 이 경우는 어떨까?

```jsx
let x = 1;
{
  console.log(x); //1
}
```

스코프 체인을 통해서 x는 1이라고 콘솔에 출력된 것을 확인할 수 있다.

그런데 만약, 이럴 경우는 어떻게 될까?

```jsx
let x = 1;
{
  console.log(x);
  let x = 2;
}
```

→ 바로 x를 초기화해주기 전까지는 접근이 불가능하다는 에러가 뜬다.

그 이유는 자바스크립트 엔진이 코드를 실행하기 전 쭉 코드를 스캔하면서 렉시컬 환경을 만드는데 이미 내부 스코프에서 x가 선언되었다는 선언을 가지고 있고 그 선언만 호이스팅이 되었기 때문에 내부 스코프에 x가 있긴 있지만 값까지 초기화되지 않았는데 내부에서 먼저 호출하였기 때문에 위와 같은 에러가 뜨는 것이다.

## var

일반 코딩 방식과 어긋나서 개발하면서도 헷갈리고 문제가 생긴다.

또한 코드의 가독성과 유지보수성에 적합하지 않다.

### 그렇다면 var의 특징을 알아보자

### 1. 변수 선언하는 키워드 없이 선언과 할당이 가능하다

```jsx
something = '🤬';
console.log(something); //🤬
```

→ 이렇게 변수 선언의 키워드 없이 선언과 할당이 가능하다보니 그냥 코드를 보면 다른 사람들은 something이라는 변수는 어디에선가 선언을 했고 재할당을 했구나 라고 인식을 하게 되기 때문에 거기서 충돌이 일어나는 것이다.

즉, 선언인지, 재할당인지 구분하기 어렵다

### 2. 중복 선언이 가능하다

```jsx
var poo = '💩';
var poo = '💩';

console.log(poo); //💩
```

→ 동일한 이름으로 재선언을 해도 아무런 에러 없이 값이 출력되는 것을 확인할 수 있다.

**let이나 const의 경우에는 어떤지 한번 알아보자**

```jsx
let num = 0;
let num = 1;
```

```jsx
const a = a;
const a = b;
```

→ 이미 선언되어 다시 선언할 수 없다는 에러가 뜨는 것을 확인할 수 있다.

이렇게 var는 중복 선언이 가능해서 내가 이미 선언을 했는지 안했는지를 몰라 중복해서 선언을 하게 되면 나도 모르게 실수를 하고 버그를 만들어내게 되는 것이다.

특히 협업을 하게 된다면 각자의 코드를 보고 중복 선언인지 아니면 첫 선언인지를 알 수 없어 문제가 생기게 된다.

### 3. 블록 레벨 스코프가 안됨

```jsx
var apple = '사과';
{
  var apple = '🍎';
}

console.log(apple);
```

전역으로 apple은 사과라고 선언하고 블록 안에서 apple은 '🍎'라고 선언을 했다.

그리고 블럭 밖에서 apple을 호출했다.

만약 let, const의 경우에서는 블럭 밖에서는 내부에 접근을 할 수 없기 때문에 사과가 콘솔에 찍히는 것을 알 수 있다.

**그렇다면 var 경우에는 어떤 값이 콘솔에 찍힐까?**

바로 '🍎'가 찍히는 것을 확인할 수 있다.

블록 레벨 스코프가 완전히 무시되어진다.

### 4. 함수 레벨 스코프만 지원된다

```jsx
function example() {
  var dog = '🦮';
}
console.log(dog);
```

이렇게 함수 외부에서 dog를 호출하였을 경우 dog is not defined라는 에러가 뜨는 것을 볼 수 있다.
